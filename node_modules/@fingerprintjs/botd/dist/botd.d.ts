/**
 * Fingerprint BotD v1.6.5 - Copyright (c) FingerprintJS, Inc, 2023 (https://fingerprint.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */

declare function getAppVersion(): string;

declare function getDocumentElementKeys(): string[];

declare function getErrorTrace(): string;

declare function getEvalLength(): number;

declare function getFunctionBind(): string;

declare function getLanguages(): string[][];

declare function areMimeTypesConsistent(): boolean;

declare function getNotificationPermissions(): Promise<boolean>;

declare function getPluginsArray(): boolean;

declare function getPluginsLength(): number;

interface ProcessPayload {
    type?: string;
    versions?: {
        electron?: string;
    };
}
declare function getProcess(): ProcessPayload;

declare function getProductSub(): string;

declare function getRTT(): number;

declare function getUserAgent(): string;

declare function getWebDriver(): boolean;

interface WebGLPayload {
    vendor: string;
    renderer: string;
}
declare function getWebGL(): WebGLPayload;

declare function getWindowExternal(): string;

interface WindowSizePayload {
    outerWidth: number;
    outerHeight: number;
    innerWidth: number;
    innerHeight: number;
}
declare function getWindowSize(): WindowSizePayload;

type BotDetectionResult = {
    bot: true;
    botKind: BotKind;
} | {
    bot: false;
};
/**
 * Enum for the source state.
 *
 * @readonly
 * @enum {number}
 */
declare const enum State {
    Success = 0,
    Undefined = -1,
    NotFunction = -2,
    UnexpectedBehaviour = -3,
    Null = -4
}
/**
 * Enum for types of bots.
 * Specific types of bots come first, followed by automation technologies.
 *
 * @readonly
 * @enum {string}
 */
declare const BotKind: {
    readonly Awesomium: "awesomium";
    readonly Cef: "cef";
    readonly CefSharp: "cefsharp";
    readonly CoachJS: "coachjs";
    readonly Electron: "electron";
    readonly FMiner: "fminer";
    readonly Geb: "geb";
    readonly NightmareJS: "nightmarejs";
    readonly Phantomas: "phantomas";
    readonly PhantomJS: "phantomjs";
    readonly Rhino: "rhino";
    readonly Selenium: "selenium";
    readonly Sequentum: "sequentum";
    readonly SlimerJS: "slimerjs";
    readonly WebDriverIO: "webdriverio";
    readonly WebDriver: "webdriver";
    readonly HeadlessChrome: "headless_chrome";
    readonly Unknown: "unknown";
};
type BotKind = typeof BotKind[keyof typeof BotKind];
/**
 * Represents a component with state and value.
 */
type Component<T> = {
    state: State.Success;
    value: T;
} | {
    state: Exclude<State, State.Success>;
    error: string;
};
type AbstractComponentDict = Record<string, Component<any>>;
type AbstractDetectionsDict = Record<string, BotDetectionResult>;
/**
 * Interface for classes that represent a bot detector.
 *
 * @interface BotDetectorInterface
 */
interface BotDetectorInterface {
    /**
     * Performs bot detection. Should be called after `collect()`.
     */
    detect(): BotDetectionResult;
    /**
     * Collects data from sources. You can retrieve the data using `getComponents()`.
     */
    collect(): Promise<AbstractComponentDict>;
    /**
     * Returns the collected data. Should be called after `collect()`.
     */
    getComponents(): AbstractComponentDict | undefined;
    /**
     * Returns detection result for each detector. Should be called after `detect()`.
     */
    getDetections(): AbstractDetectionsDict | undefined;
}
/**
 * Bot detection error.
 */
declare class BotdError extends Error {
    state: Exclude<State, State.Success>;
    /**
     * Creates a new BotdError.
     *
     * @class
     */
    constructor(state: Exclude<State, State.Success>, message: string);
}

type DistinctivePropertiesPayload = Partial<Record<BotKind, boolean>>;
declare function checkDistinctiveProperties(): DistinctivePropertiesPayload;

declare const sources: {
    userAgent: typeof getUserAgent;
    appVersion: typeof getAppVersion;
    rtt: typeof getRTT;
    windowSize: typeof getWindowSize;
    pluginsLength: typeof getPluginsLength;
    pluginsArray: typeof getPluginsArray;
    errorTrace: typeof getErrorTrace;
    productSub: typeof getProductSub;
    windowExternal: typeof getWindowExternal;
    mimeTypesConsistent: typeof areMimeTypesConsistent;
    evalLength: typeof getEvalLength;
    webGL: typeof getWebGL;
    webDriver: typeof getWebDriver;
    languages: typeof getLanguages;
    notificationPermissions: typeof getNotificationPermissions;
    documentElementKeys: typeof getDocumentElementKeys;
    functionBind: typeof getFunctionBind;
    process: typeof getProcess;
    distinctiveProps: typeof checkDistinctiveProperties;
};

/**
 * Options for BotD loading
 */
interface LoadOptions {
    /**
     * Set `false` to disable the unpersonalized AJAX request that the agent sends to collect installation statistics.
     * It's always disabled in the version published to the FingerprintJS CDN.
     */
    monitoring?: boolean;
}
declare function load({ monitoring }?: Readonly<LoadOptions>): Promise<BotDetectorInterface>;
declare const _default: {
    load: typeof load;
};

export { BotDetectionResult, BotKind, BotdError, DistinctivePropertiesPayload, LoadOptions, ProcessPayload, WindowSizePayload, _default as default, load, sources };
